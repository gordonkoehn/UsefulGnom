"""
Common code for unit testing of rules generated with Snakemake 8.18.2.
"""

import os
import sys

from pathlib import Path
from typing import List

import csv
import math


class OutputChecker:
    """
    Check the output of a Snakemake rule given only the directories
    of the input data, expected output, and the working directory and
    config directory of the rule.

    This function is based on the autogenerated Snakemake and modified
    to be suitable for unit testing across different machines for
    tolerance testing.
    """

    def __init__(
        self,
        data_path,
        expected_path,
        workdir,
        configdir=None,
        tolerance=1e-4,
        ignore_files: List[str] = ["ignore"],
    ):
        """
        Initialize the output checker.
        """
        self.data_path = data_path
        self.expected_path = expected_path
        self.workdir = workdir
        self.tolerance = tolerance
        self.ignore_files = ignore_files

        if configdir is None:
            self.configdir = workdir / "config"
        else:
            self.configdir = configdir

    def check(self):
        """
        Check the output of the rule.
        """
        input_files = set(
            (Path(path) / f).relative_to(self.workdir)
            for path, subdirs, files in os.walk(self.data_path)
            for f in files
        )

        config_files = set(
            (Path(path) / f).relative_to(self.workdir)
            for path, subdirs, files in os.walk(self.configdir)
            for f in files
        )

        expected_files = set(
            (Path(path) / f).relative_to(self.expected_path)
            for path, subdirs, files in os.walk(self.expected_path)
            for f in files
        )
        unexpected_files = set()
        for path, subdirs, files in os.walk(self.workdir):
            for f in files:
                f = (Path(path) / f).relative_to(self.workdir)
                if str(f).startswith(".snakemake"):
                    continue
                if self.ignore_files:
                    if any(str(f).endswith(prefix) for prefix in self.ignore_files):
                        print(f"Ignoring file by type: {str(f)}")
                        continue
                if f in expected_files:
                    self.compare_files(self.workdir / f, self.expected_path / f)
                elif f in input_files:
                    # ignore input files
                    print(f"Ignoring input file:  {str(f)}")
                    print(f, file=sys.stderr)
                    pass
                elif f in config_files:
                    # ignore config files
                    print(f"Ignoring config file:  {str(f)}")
                    print(f, file=sys.stderr)
                    pass
                else:
                    unexpected_files.add(f)
        if unexpected_files:
            print("Unexpected files: ", file=sys.stderr)
            print(unexpected_files, file=sys.stderr)
            raise ValueError(
                "Unexpected files:\n{}".format(
                    "\n".join(sorted(map(str, unexpected_files)))
                )
            )

    def compare_files(self, generated_file, expected_file):
        """
        Compare two files
        """

        ext1 = os.path.splitext(generated_file)[1].lower()
        ext2 = os.path.splitext(expected_file)[1].lower()

        if ext1 != ext2:
            raise ValueError("File extensions do not match")

        if ext1 == ".json":
            raise NotImplementedError("JSON comparison not implemented")
        elif ext1 in [".csv", ".tsv"]:
            return self.compare_delimited_files(
                generated_file, expected_file, self.tolerance, ext1
            )
        else:
            raise ValueError(f"Unsupported file type: {ext1}")

    def compare_delimited_files(self, file1, file2, tolerance, ext):
        """
        Compare two delimited files, either CSV or TSV.

        The delimiter is determined by the file extension.
        The comparison is done row by row, and the values are compared
        using the `compare_values` method, numbers are compared using
        the given tolerance and strings are compared directly.

        Args:
            file1 (str): Path to the first file
            file2 (str): Path to the second file
            tolerance (float): Tolerance for comparing numbers
            ext (str): File extension, either `.csv` or `.tsv`

        Returns:
            bool: True if the files are the same, False otherwise
            str: Message indicating the result of the comparison

        Raises:
            AssertionError: If the row length of the two files do not match
            AssertionError: If the values in the two files do not match
        """
        delimiter = "\t" if ext == ".tsv" else ","
        with open(file1, "r") as f1, open(file2, "r") as f2:
            reader1 = csv.reader(f1, delimiter=delimiter)
            reader2 = csv.reader(f2, delimiter=delimiter)

            for row1, row2 in zip(reader1, reader2):
                if len(row1) != len(row2):
                    raise AssertionError(
                        f"Row length mismatch: {len(row1)} vs {len(row2)}"
                    )

                for val1, val2 in zip(row1, row2):
                    print(f"Comparing {val1} and {val2}")
                    if not self.compare_values(val1, val2, tolerance):
                        raise AssertionError(
                            f"Value mismatch: {val1} vs {val2} in {file1}"
                            f"and {file2}, and row {row1} and {row2}"
                        )

        return True, f"{ext[1:].upper()} comparison complete"

    def compare_values(self, val1, val2, tolerance):
        """
        Compare two values, either numbers or strings.
        Numbers are compared using the given tolerance, and strings
        are compared directly.

        Args:
            val1 (str): First value
            val2 (str): Second value
            tolerance (float): Tolerance for comparing numbers
        """
        try:
            num1 = float(val1)
            num2 = float(val2)
            return math.isclose(num1, num2, rel_tol=tolerance, abs_tol=tolerance)
        except (ValueError, TypeError):
            return val1 == val2
